{
  "dsInSACourse": {
    "modules": {
      "MODULE_1": {
        "lectures": [
          {
            "text": "<b><i>Системный аналитик – новая IT-роль</i></b><br><br>Профессия системного аналитика – современная сфера деятельности, основанная на решении организационных задач с применением системного анализа. Область системной аналитики возникла в России совсем недавно и причиной этому стал спрос на эффективную автоматизацию процессов в бизнесе. Модификация процессов в программную систему в крупных фирмах находится буквально в руках одной новой IT-роли – системного аналитика. Такой специалист проводит анализ поставленных заказчиком задач и создаёт работающее решение, которое позволяет повысить эффективность работы бизнеса."
          },
          {
            "text": "<br><br><b><i>Ключевая роль</i></b><br><br>На IT-проекте по автоматизации системы компании, ключевая роль такого аналитика заключается в разработке пакета требований от бизнеса к программному обеспечению и постановке задач на разработку и тестирование. Рассмотрим детальное шаги деятельности системного аналитика:"
          },
          {
            "text": "<br><br><b><i>1 шаг – Сбор требований</i></b><br><br>Шаг характеризуется сбором требований, их анализом и документированием системным аналитиком. Детализированные обязанности аналитика:<br><br><pre>• Выявление целей разработки системы у заказчика/ заинтересованных лиц</pre><br><pre>• Интервьюирование представителей бизнеса заказчика, потенциальных пользователей системы</pre><br><pre>• Коммуникация с бизнес-аналитиком для получения бизнес-требований к системе</pre>"
          },
          {
            "text": "<br><br><b><i> </i></b>"
          }
        ],
        "tests": [
          {
            "textOfQuestion": "",
            "answerOptions": [
              "Вариант 1",
              "Вариант 2",
              "Вариант 3",
              "Вариант 4"
            ],
            "correctAnswer": "Вариант 4"
          }
        ]
      },
      "MODULE_2": {
        "lectures": [
          {
            "text": "<b><i>Список – структура данных</i></b><br><br>Список – линейная структура данных, представляющая собой упорядоченную коллекцию объектов. Для удобства и простоты понимания в учебном курсе будем использовать программные вставки на языке программирования высокого уровня Java."
          },
          {
            "text": "<br><br><b><i>Характеристики структуры данных</i></b><br><br><pre>• Каждый элемент имеет свой индекс, посредством которого можно получить доступ к определённому элементу списка</pre><br><pre>• Индексация начинается с 0</pre><br><pre>• Список может быть как типизированным, так и нетипизированным (например, в Java применяются в таких случаях Java Generics). В случае использования дженериков список может содержать объекты различных типов</pre><br><pre>• Список может содержать повторяющиеся элементы</pre><br><pre>• Для создания списка не нужно задавать размерность, поскольку список – динамическая структура данных</pre><br><pre>• Список может представлять собой структуру данных, реализованную как на базе массива, так и на базе цепочки связанных элементов. В Java это соответственно ArrayList и LinkedList."
          },
          {
            "text": "<br><br><b><i>Методы для работы со списком</i></b><br><br>Полезные методы для работы со структурной данных – списком:<br><br><pre>• void add(int index, E obj): добавляет в список по индексу index объект obj</pre><br><pre>• boolean addAll(int index, Collection<? extends E> col): добавляет в список по индексу index все элементы коллекции col. Если в результате добавления список был изменен, то возвращается true, иначе возвращается false</pre><br><pre>• E get(int index): возвращает объект из списка по индексу index</pre><br><pre>• int indexOf(Object obj): возвращает индекс первого вхождения объекта obj в список. Если объект не найден, то возвращается -1</pre><br><pre>• int lastIndexOf(Object obj): возвращает индекс последнего вхождения объекта obj в список. Если объект не найден, то возвращается -1</pre><br><pre>• ListIterator<E> listIterator (): возвращает объект ListIterator для обхода элементов списка</pre><br><pre>• static <E> List<E> of(элементы): создает из набора элементов объект List</pre><br><pre>• E remove(int index): удаляет объект из списка по индексу index, возвращая при этом удаленный объект</pre><br><pre>• E set(int index, E obj): присваивает значение объекта obj элементу, который находится по индексу index</pre><br><pre>• void sort(Comparator<? super E> comp): сортирует список с помощью компаратора comp</pre><br><pre>• List<E> subList(int start, int end): получает набор элементов, которые находятся в списке между индексами start и end</pre><br><pre>• Boolean isContains(Object obj, List<E> list): возвращает true, если объект obj содержится в списке list, в противном случае возвращает false,<br>, где E – тип элемента списка."
          },
          {
            "text": "<br><br><b><i>ArrayList – список на основе массива</i></b><br><br>ArrayList применяется для случаев, где основная работа со структурой заключается в доступе к элементу списка по индексу и не предполагает вставки новых элементов в начало или середину списка. Практически все операции такого списка выполняются за константное время O(1). Исключением являются операции вставки элемента в начало, середину или его удаления. Такие операции требуют сдвига элементов списка, стоящих справа от вставляемого/ удаляемого и выполняются за линейное время O(n), где n – количество элементов в списке."
          },
          {
            "text": "<br><br><b><i>LinkedList – связный список</i></b><br><br>LinkedList – список, хранящий в себе объекты и ссылки на начало и конец списка. Каждый элемент списка хранит в себе ссылки на предыдущий и следующий элементы списка. Такой вид списка применяется в случаях, когда необходимо часто вставлять и/или удалять элементы внутри списка. Такие операции выполняются в основном за константное время O(1). Недостатком такого списка является доступ к неграничному элементу списка, поскольку такая операция небыстрая и выполняется за линейное время O(n)."
          },
          {
            "text": "<br><br><b><i>Использование списка при написании системной аналитики</i></b><br><br>Термин «список» может фигурировать в работе аналитика практически на всех этапах его деятельности. Спросите, почему? Ведь аналитик до написания требований занимается интервьюированием представителей бизнеса и не занимается подготовкой документации для разработчиков и, как следствие, не имеет дела с техническими реалиями. Поскольку аналитик начинает проектирование системы и её моделей на этапе интервью с представителями бизнеса, то представление данных в виде списка может появиться уже после анализа бизнес-требований от бизнес-аналитика.<br><br>Список – это последовательность. Следовательно, применять данную структуру данных следует при необходимости хранить набор одинаковых по типу и логике объектов.<br>Рассмотрим случаи, когда применение списка будет наиболее выгодным вариантом для аналитика:<br><pre><br>1. Бизнес-требование:</pre><br><br>Сущность «Документ» предполагает множество перечней. Один документ может содержать от 1 до N перечней. Каждый перечень содержит определённый текстовый набор, ведённый пользователем. По умолчанию, в каждый документ, сохраняемый без перечней, добавляется перечень по умолчанию со стандартным текстовым набором. В системе достаточно иметь данную сущность документа и получать последовательность перечней. Каждый новый перечень добавляется в конец. Пользователь также в праве удалить любой из перечней, если таковой не является единственным.<br><br>Системное требование:<br><br>Модель «Document» должна содержать список перечней List<Scroll>. Scroll – модель перечня, содержащая текстовый атрибут String text. Причём, документ должен содержать, как минимум, один перечень. Таким образом, при создании объекта класса «Document» необходимо по умолчанию ему добавлять в список перечней объект класса «Scroll» со стандартным текстовым набором, если пользователь не позаботился о добавлении хотя бы одного перечня до сохранения объекта «Document».<br>Пользователь должен иметь следующие функции для работы с перечнями:<br><pre>• Добавление перечня add(Scroll obj)</pre><br><pre>• Удаление перечня remove(Scroll obj)</pre><br><pre>• Получение перечня по его индексу getScrollByIndex(int index)</pre><br><pre>• Получение коллекции перечней getAllScrolls()<br><br>Итог:<br><br>Как видим, при написании системного требования аналитику потребовалось не только понимание рационального применения данного вида структуры данных в текущей ситуации, но и основные свойства, которыми обладает список (наличие методов для работы со списком: добавление, удаление элементов, получение всех элементов)."
          },
          {
            "text": "<br><br><b><i> </i></b>"
          }
        ],
        "tests": [
          {
            "textOfQuestion": "<b>К каким типам структур данных относится список?</b>",
            "answerOptions": [
              "Линейный и статический",
              "Линейный и динамический",
              "Нелинейный",
              "Нелинейный и динамический"
            ],
            "correctAnswer": "Линейный и динамический"
          },
          {
            "textOfQuestion": "<b>Выберите верное утверждение по свойствам структуры данных списка</b>",
            "answerOptions": [
              "Доступ к элементам списка на основе массива получить через индекс невозможно",
              "Индексация элементов в списке, как и в массиве, начинается с 1",
              "Связный список содержит в себе исключительно элементы со ссылками на предыдущий и следующий",
              "Доступ к элементу списка на основе массива можно получить за константное время O(1)"
            ],
            "correctAnswer": "Доступ к элементу списка на основе массива можно получить за константное время O(1)"
          },
          {
            "textOfQuestion": "<b>Одним из свойств списка НЕ является</b>",
            "answerOptions": [
              "Возможность получения элемента по его индексу",
              "Возможность не задавать размерность списка при его создании",
              "Возможность хранения элементов вида «ключ, значение»",
              "Возможность хранения элементов различных типов"
            ],
            "correctAnswer": "Возможность хранения элементов вида «ключ, значение»"
          },
          {
            "textOfQuestion": "<b>Организация R реализует процесс обслуживания заказов на автомобильные детали. При автоматизации электронного поддержания заказов данного процесса системный аналитик столкнулся с проблемой выбора вида списка и метода работы с ним, поскольку для заказчика имеет важное значение скорость обработки заказов, а именно, скорость удаления отменённых заказов. При этом запрос на удаление может быть на любой заказ из 1 000 000 последовательности заказов.<br>Какое решение об оптимальном выборе структуры данных и механизме работы с ней должен принять системный аналитик, опираясь исключительно на потребности заказчика?</b>",
            "answerOptions": [
              "Список на основе массива и метод сортировки заказов",
              "Список на основе связного списка и метод добавления элемента в конец",
              "Список на основе массива и метод получения элемента по его индексу",
              "Список на основе связного списка и метод удаления элемента"
            ],
            "correctAnswer": "Список на основе связного списка и метод удаления элемента"
          },
          {
            "textOfQuestion": "<b>Список допускает наличие одинаковых элементов?</b>",
            "answerOptions": [
              "Да",
              "Нет",
              "В случае, если это связный список",
              "В случае, если список на основе массива"
            ],
            "correctAnswer": "Да"
          }
        ]
      }
    }
  }
}